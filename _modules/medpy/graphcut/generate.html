<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>medpy.graphcut.generate &mdash; MedPy 0.4.0 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="MedPy 0.4.0 documentation" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/loli/medpy/">GitHub</a></li>
        <li class="active"><a href="https://pypi.python.org/pypi/MedPy/">PyPi</a></li>
	
        <li class="active"><a href="../../../index.html">MedPy 0.4.0 documentation</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for medpy.graphcut.generate</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2013 Oskar Maier</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># author Oskar Maier</span>
<span class="c1"># version r0.3.0</span>
<span class="c1"># since 2012-01-18</span>
<span class="c1"># status Release</span>

<span class="c1"># build-in modules</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c1"># third-party modules</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="c1"># own modules</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="k">import</span> <span class="n">Logger</span>
<span class="kn">from</span> <span class="nn">.graph</span> <span class="k">import</span> <span class="n">GCGraph</span>
<span class="kn">from</span> <span class="nn">medpy.graphcut.energy_label</span> <span class="k">import</span> <span class="n">__check_label_image</span>

<div class="viewcode-block" id="graph_from_voxels"><a class="viewcode-back" href="../../../generated/medpy.graphcut.generate.graph_from_voxels.html#medpy.graphcut.generate.graph_from_voxels">[docs]</a><span class="k">def</span> <span class="nf">graph_from_voxels</span><span class="p">(</span><span class="n">fg_markers</span><span class="p">,</span>
                        <span class="n">bg_markers</span><span class="p">,</span>
                        <span class="n">regional_term</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">boundary_term</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">regional_term_args</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">boundary_term_args</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a graph-cut ready graph to segment a nD image using the voxel neighbourhood.</span>
<span class="sd">    </span>
<span class="sd">    Create a `~medpy.graphcut.maxflow.GraphDouble` object for all voxels of an image with a</span>
<span class="sd">    :math:`ndim * 2` neighbourhood.</span>
<span class="sd">    </span>
<span class="sd">    Every voxel of the image is regarded as a node. They are connected to their immediate</span>
<span class="sd">    neighbours via arcs. If to voxels are neighbours is determined using</span>
<span class="sd">    :math:`ndim*2`-connectedness (e.g. :math:`3*2=6` for 3D). In the next step the arcs weights</span>
<span class="sd">    (n-weights) are computed using the supplied ``boundary_term`` function</span>
<span class="sd">    (see :mod:`~medpy.graphcut.energy_voxel` for a selection).</span>
<span class="sd">    </span>
<span class="sd">    Implicitly the graph holds two additional nodes: the source and the sink, so called</span>
<span class="sd">    terminal nodes. These are connected with all other nodes through arcs of an initial</span>
<span class="sd">    weight (t-weight) of zero.</span>
<span class="sd">    All voxels that are under the foreground markers are considered to be tightly bound</span>
<span class="sd">    to the source: The t-weight of the arc from source to these nodes is set to a maximum</span>
<span class="sd">    value. The same goes for the background markers: The covered voxels receive a maximum</span>
<span class="sd">    (`~medpy.graphcut.graph.GCGraph.MAX`) t-weight for their arc towards the sink.</span>
<span class="sd">    </span>
<span class="sd">    All other t-weights are set using the supplied ``regional_term`` function</span>
<span class="sd">    (see :mod:`~medpy.graphcut.energy_voxel` for a selection).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fg_markers : ndarray</span>
<span class="sd">        The foreground markers as binary array of the same shape as the original image.</span>
<span class="sd">    bg_markers : ndarray</span>
<span class="sd">        The background markers as binary array of the same shape as the original image.</span>
<span class="sd">    regional_term : function</span>
<span class="sd">        This can be either `False`, in which case all t-weights are set to 0, except for</span>
<span class="sd">        the nodes that are directly connected to the source or sink; or a function, in</span>
<span class="sd">        which case the supplied function is used to compute the t_edges. It has to</span>
<span class="sd">        have the following signature *regional_term(graph, regional_term_args)*, and is</span>
<span class="sd">        supposed to compute (source_t_weight, sink_t_weight) for all voxels of the image</span>
<span class="sd">        and add these to the passed `~medpy.graphcut.graph.GCGraph` object. The weights</span>
<span class="sd">        have only to be computed for nodes where they do not equal zero. Additional</span>
<span class="sd">        parameters can be passed to the function via the ``regional_term_args`` parameter.</span>
<span class="sd">    boundary_term : function</span>
<span class="sd">        This can be either `False`, in which case all n-edges, i.e. between all nodes</span>
<span class="sd">        that are not source or sink, are set to 0; or a function, in which case the</span>
<span class="sd">        supplied function is used to compute the edge weights. It has to have the</span>
<span class="sd">        following signature *boundary_term(graph, boundary_term_args)*, and is supposed</span>
<span class="sd">        to compute the edges between the graphs nodes and to add them to the supplied</span>
<span class="sd">        `~medpy.graphcut.graph.GCGraph` object. Additional parameters can be passed to</span>
<span class="sd">        the function via the ``boundary_term_args`` parameter.</span>
<span class="sd">    regional_term_args : tuple</span>
<span class="sd">        Use this to pass some additional parameters to the ``regional_term`` function.</span>
<span class="sd">    boundary_term_args : tuple    </span>
<span class="sd">        Use this to pass some additional parameters to the ``boundary_term`` function.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    graph : `~medpy.graphcut.maxflow.GraphDouble`</span>
<span class="sd">        The created graph, ready to execute the graph-cut.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If an argument is malformed.</span>
<span class="sd">    FunctionError</span>
<span class="sd">        If one of the supplied functions returns unexpected results.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If a voxel is marked as both, foreground and background, the background marker</span>
<span class="sd">    is given higher priority.</span>
<span class="sd">     </span>
<span class="sd">    All arcs whose weight is not explicitly set are assumed to carry a weight of zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare logger</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="n">getInstance</span><span class="p">()</span>
    
    <span class="c1"># prepare result graph</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Assuming </span><span class="si">{}</span><span class="s1"> nodes and </span><span class="si">{}</span><span class="s1"> edges for image of shape </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">__voxel_4conectedness</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">fg_markers</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> 
    <span class="n">graph</span> <span class="o">=</span> <span class="n">GCGraph</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">__voxel_4conectedness</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing attribute tests...&#39;</span><span class="p">)</span>
    
    <span class="c1"># check, set and convert all supplied parameters</span>
    <span class="n">fg_markers</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fg_markers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">bg_markers</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bg_markers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    
    <span class="c1"># set dummy functions if not supplied</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">regional_term</span><span class="p">:</span> <span class="n">regional_term</span> <span class="o">=</span> <span class="n">__regional_term_voxel</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">boundary_term</span><span class="p">:</span> <span class="n">boundary_term</span> <span class="o">=</span> <span class="n">__boundary_term_voxel</span>
    
    <span class="c1"># check supplied functions and their signature</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">regional_term</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">regional_term</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;regional_term has to be a callable object which takes two parameter.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">boundary_term</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">boundary_term</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;boundary_term has to be a callable object which takes two parameters.&#39;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;#nodes=</span><span class="si">{}</span><span class="s1">, #hardwired-nodes source/sink=</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                                                                        <span class="nb">len</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span>
                                                                        <span class="nb">len</span><span class="p">(</span><span class="n">bg_markers</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])))</span>
    
    <span class="c1"># compute the weights of all edges from the source and to the sink i.e.</span>
    <span class="c1"># compute the weights of the t_edges Wt</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing and adding terminal edge weights...&#39;</span><span class="p">)</span>
    <span class="n">regional_term</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">regional_term_args</span><span class="p">)</span>

    <span class="c1"># compute the weights of the edges between the neighbouring nodes i.e.</span>
    <span class="c1"># compute the weights of the n_edges Wr</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing and adding inter-node edge weights...&#39;</span><span class="p">)</span>
    <span class="n">boundary_term</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">boundary_term_args</span><span class="p">)</span>
    
    <span class="c1"># collect all voxels that are under the foreground resp. background markers i.e.</span>
    <span class="c1"># collect all nodes that are connected to the source resp. sink</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting terminal weights for the markers...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">scipy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">fg_markers</span><span class="p">):</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_source_nodes</span><span class="p">(</span><span class="n">fg_markers</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">scipy</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">bg_markers</span><span class="p">):</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_sink_nodes</span><span class="p">(</span><span class="n">bg_markers</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>    
    
    <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span></div>

<div class="viewcode-block" id="graph_from_labels"><a class="viewcode-back" href="../../../generated/medpy.graphcut.generate.graph_from_labels.html#medpy.graphcut.generate.graph_from_labels">[docs]</a><span class="k">def</span> <span class="nf">graph_from_labels</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span>
                        <span class="n">fg_markers</span><span class="p">,</span>
                        <span class="n">bg_markers</span><span class="p">,</span>
                        <span class="n">regional_term</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">boundary_term</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">regional_term_args</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">boundary_term_args</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a graph-cut ready graph to segment a nD image using the region neighbourhood.</span>
<span class="sd">    </span>
<span class="sd">    Create a `~medpy.graphcut.maxflow.GraphDouble` object for all regions of a nD label</span>
<span class="sd">    image.</span>
<span class="sd">    </span>
<span class="sd">    Every region of the label image is regarded as a node. They are connected to their</span>
<span class="sd">    immediate neighbours by arcs. If to regions are neighbours is determined using</span>
<span class="sd">    :math:`ndim*2`-connectedness (e.g. :math:`3*2=6` for 3D).</span>
<span class="sd">    In the next step the arcs weights (n-weights) are computed using the supplied</span>
<span class="sd">    ``boundary_term`` function (see :mod:`~medpy.graphcut.energy_voxel` for a selection).</span>
<span class="sd">    </span>
<span class="sd">    Implicitly the graph holds two additional nodes: the source and the sink, so called</span>
<span class="sd">    terminal nodes. These are connected with all other nodes through arcs of an initial</span>
<span class="sd">    weight (t-weight) of zero.</span>
<span class="sd">    All regions that are under the foreground markers are considered to be tightly bound</span>
<span class="sd">    to the source: The t-weight of the arc from source to these nodes is set to a maximum </span>
<span class="sd">    value. The same goes for the background markers: The covered regions receive a</span>
<span class="sd">    maximum (`~medpy.graphcut.graph.GCGraph.MAX`) t-weight for their arc towards the sink.</span>
<span class="sd">    </span>
<span class="sd">    All other t-weights are set using the supplied ``regional_term`` function</span>
<span class="sd">    (see :mod:`~medpy.graphcut.energy_voxel` for a selection).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    label_image: ndarray</span>
<span class="sd">        The label image as an array cwhere each voxel carries the id of the region it</span>
<span class="sd">        belongs to. Note that the region labels have to start from 1 and be continuous</span>
<span class="sd">        (can be achieved with `~medpy.filter.label.relabel`).</span>
<span class="sd">    fg_markers : ndarray</span>
<span class="sd">        The foreground markers as binary array of the same shape as the original image.</span>
<span class="sd">    bg_markers : ndarray</span>
<span class="sd">        The background markers as binary array of the same shape as the original image.</span>
<span class="sd">    regional_term : function</span>
<span class="sd">        This can be either `False`, in which case all t-weights are set to 0, except for</span>
<span class="sd">        the nodes that are directly connected to the source or sink; or a function, in</span>
<span class="sd">        which case the supplied function is used to compute the t_edges. It has to</span>
<span class="sd">        have the following signature *regional_term(graph, regional_term_args)*, and is</span>
<span class="sd">        supposed to compute (source_t_weight, sink_t_weight) for all regions of the image</span>
<span class="sd">        and add these to the passed `~medpy.graphcut.graph.GCGraph` object. The weights</span>
<span class="sd">        have only to be computed for nodes where they do not equal zero. Additional</span>
<span class="sd">        parameters can be passed to the function via the ``regional_term_args`` parameter.</span>
<span class="sd">    boundary_term : function</span>
<span class="sd">        This can be either `False`, in which case all n-edges, i.e. between all nodes</span>
<span class="sd">        that are not source or sink, are set to 0; or a function, in which case the</span>
<span class="sd">        supplied function is used to compute the edge weights. It has to have the</span>
<span class="sd">        following signature *boundary_term(graph, boundary_term_args)*, and is supposed</span>
<span class="sd">        to compute the edges between all adjacent regions of the image and to add them</span>
<span class="sd">        to the supplied `~medpy.graphcut.graph.GCGraph` object. Additional parameters</span>
<span class="sd">        can be passed to the function via the ``boundary_term_args`` parameter.</span>
<span class="sd">    regional_term_args : tuple</span>
<span class="sd">        Use this to pass some additional parameters to the ``regional_term`` function.</span>
<span class="sd">    boundary_term_args : tuple    </span>
<span class="sd">        Use this to pass some additional parameters to the ``boundary_term`` function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    graph : `~medpy.graphcut.maxflow.GraphDouble`</span>
<span class="sd">        The created graph, ready to execute the graph-cut.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If an argument is malformed.</span>
<span class="sd">    FunctionError</span>
<span class="sd">        If one of the supplied functions returns unexpected results.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If a voxel is marked as both, foreground and background, the background marker</span>
<span class="sd">    is given higher priority.</span>
<span class="sd">     </span>
<span class="sd">    All arcs whose weight is not explicitly set are assumed to carry a weight of zero.    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># prepare logger</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="n">getInstance</span><span class="p">()</span>
    
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing attribute tests...&#39;</span><span class="p">)</span>
    
    <span class="c1"># check, set and convert all supplied parameters</span>
    <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">fg_markers</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fg_markers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">bg_markers</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bg_markers</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    
    <span class="n">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># set dummy functions if not supplied</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">regional_term</span><span class="p">:</span> <span class="n">regional_term</span> <span class="o">=</span> <span class="n">__regional_term_label</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">boundary_term</span><span class="p">:</span> <span class="n">boundary_term</span> <span class="o">=</span> <span class="n">__boundary_term_label</span>
    
    <span class="c1"># check supplied functions and their signature</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">regional_term</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">3</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">regional_term</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;regional_term has to be a callable object which takes three parameters.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">boundary_term</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">3</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">boundary_term</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;boundary_term has to be a callable object which takes three parameters.&#39;</span><span class="p">)</span>    
    
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Determining number of nodes and edges.&#39;</span><span class="p">)</span>
    
    <span class="c1"># compute number of nodes and edges</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">))</span>
    <span class="c1"># POSSIBILITY 1: guess the number of edges (in the best situation is faster but requires a little bit more memory. In the worst is slower.)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">nodes</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;guessed: #nodes=</span><span class="si">{}</span><span class="s1"> nodes / #edges=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">))</span>
    <span class="c1"># POSSIBILITY 2: compute the edges (slow)</span>
    <span class="c1">#edges = len(__compute_edges(label_image))</span>
    <span class="c1">#logger.debug(&#39;computed: #nodes={} nodes / #edges={}&#39;.format(nodes, edges))</span>
        
    <span class="c1"># prepare result graph</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">GCGraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
                                        
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;#hardwired-nodes source/sink=</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">fg_markers</span><span class="p">])),</span>
                                                             <span class="nb">len</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">bg_markers</span><span class="p">]))))</span>
                 
    <span class="c1">#logger.info(&#39;Extracting the regions bounding boxes...&#39;)</span>
    <span class="c1"># extract the bounding boxes</span>
    <span class="c1">#bounding_boxes = find_objects(label_image)</span>
        
    <span class="c1"># compute the weights of all edges from the source and to the sink i.e.</span>
    <span class="c1"># compute the weights of the t_edges Wt</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing and adding terminal edge weights...&#39;</span><span class="p">)</span>
    <span class="c1">#regions = set(graph.get_nodes()) - set(graph.get_source_nodes()) - set(graph.get_sink_nodes())</span>
    <span class="n">regional_term</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">regional_term_args</span><span class="p">)</span> <span class="c1"># bounding boxes indexed from 0 # old version: regional_term(graph, label_image, regions, bounding_boxes, regional_term_args)</span>

    <span class="c1"># compute the weights of the edges between the neighbouring nodes i.e.</span>
    <span class="c1"># compute the weights of the n_edges Wr</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing and adding inter-node edge weights...&#39;</span><span class="p">)</span>
    <span class="n">boundary_term</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">boundary_term_args</span><span class="p">)</span>
    
    <span class="c1"># collect all regions that are under the foreground resp. background markers i.e.</span>
    <span class="c1"># collect all nodes that are connected to the source resp. sink</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting terminal weights for the markers...&#39;</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">set_source_nodes</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">fg_markers</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># requires -1 to adapt to node id system</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">set_sink_nodes</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">bg_markers</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span></div>

<span class="k">def</span> <span class="nf">__regional_term_voxel</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">regional_term_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake regional_term function with the appropriate signature.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">__regional_term_label</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">regional_term_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake regional_term function with the appropriate signature.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">__boundary_term_voxel</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">boundary_term_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake regional_term function with the appropriate signature.&quot;&quot;&quot;</span>
    <span class="c1"># supplying no boundary term contradicts the whole graph cut idea.</span>
    <span class="k">return</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">__boundary_term_label</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">boundary_term_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake regional_term function with the appropriate signature.&quot;&quot;&quot;</span>
    <span class="c1"># supplying no boundary term contradicts the whole graph cut idea.</span>
    <span class="k">return</span> <span class="p">{}</span>
    
<span class="k">def</span> <span class="nf">__voxel_4conectedness</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of edges for the supplied image shape assuming 4-connectedness.</span>
<span class="sd">    </span>
<span class="sd">    The name of the function has historical reasons. Essentially it returns the number</span>
<span class="sd">    of edges assuming 4-connectedness only for 2D. For 3D it assumes 6-connectedness,</span>
<span class="sd">    etc.</span>
<span class="sd">    </span>
<span class="sd">    @param shape the shape of the image</span>
<span class="sd">    @type shape sequence</span>
<span class="sd">    @return the number of edges</span>
<span class="sd">    @rtype int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span> <span class="n">shape</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># empty resp. 1-sized dimensions have to be removed (equal to scipy.squeeze on the array)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">([(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018, Oskar Maier.
      </li>
      <li>
      Last updated on Nov 23, 2018.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.7.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>
