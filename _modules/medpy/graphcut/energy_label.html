<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>medpy.graphcut.energy_label &mdash; MedPy 0.4.0 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="MedPy 0.4.0 documentation" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/loli/medpy/">GitHub</a></li>
        <li class="active"><a href="https://pypi.python.org/pypi/MedPy/">PyPi</a></li>
	
        <li class="active"><a href="../../../index.html">MedPy 0.4.0 documentation</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for medpy.graphcut.energy_label</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2013 Oskar Maier</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># author Oskar Maier</span>
<span class="c1"># version r0.3.0</span>
<span class="c1"># since 2012-01-18</span>
<span class="c1"># status Release</span>

<span class="c1"># build-in modules</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># third-party modules</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># own modules</span>

<span class="c1"># code</span>
<div class="viewcode-block" id="boundary_difference_of_means"><a class="viewcode-back" href="../../../generated/medpy.graphcut.energy_label.boundary_difference_of_means.html#medpy.graphcut.energy_label.boundary_difference_of_means">[docs]</a><span class="k">def</span> <span class="nf">boundary_difference_of_means</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">original_image</span><span class="p">):</span> <span class="c1"># label image is not required to hold continuous ids or to start from 1</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boundary term based on the difference of means between adjacent image regions.</span>
<span class="sd">    </span>
<span class="sd">    An implementation of the boundary term, suitable to be used with the `~medpy.graphcut.generate.graph_from_labels` function.</span>
<span class="sd">    </span>
<span class="sd">    This simple energy function computes the mean values for all regions. The weights of</span>
<span class="sd">    the edges are then determined by the difference in mean values.</span>
<span class="sd">    </span>
<span class="sd">    The graph weights generated have to be strictly positive and preferably in the</span>
<span class="sd">    interval :math:`(0, 1]`. To ensure this, the maximum possible difference in mean values is computed as:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        \alpha = \|\max \bar{I} - \min \bar{I}\|</span>
<span class="sd">    </span>
<span class="sd">    , where :math:`\min \bar{I}` constitutes the lowest mean intensity value of all regions in</span>
<span class="sd">    the image, while :math:`\max \bar{I}` constitutes the highest mean intensity value With this</span>
<span class="sd">    value the weights between a region :math:`x` and its neighbour :math:`y` can be computed:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        w(x,y) = \max \left( 1 - \frac{\|\bar{I}_x - \bar{I}_y\|}{\alpha}, \epsilon \right)</span>
<span class="sd">    </span>
<span class="sd">    where :math:`\epsilon` is the smallest floating point step and thus :math:`w(x,y) \in (0, 1]` holds true.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : GCGraph</span>
<span class="sd">        The graph to add the weights to.</span>
<span class="sd">    label_image : ndarray</span>
<span class="sd">        The label image.</span>
<span class="sd">    original_image : ndarray</span>
<span class="sd">        The original image.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function requires the original image to be passed along. That means that</span>
<span class="sd">    `~medpy.graphcut.generate.graph_from_labels` has to be called with ``boundary_term_args`` set to the</span>
<span class="sd">    original image. </span>
<span class="sd">    </span>
<span class="sd">    This function is tested on 2D and 3D images and theoretically works for all dimensionalities. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to arrays if necessary</span>
    <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">original_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">original_image</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">label_image</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]:</span> <span class="c1"># strangely one this one is required to be ctype ordering</span>
        <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
        
    <span class="n">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># create a lookup-table that translates from a label id to its position in the sorted unique vector</span>
    <span class="n">labels_unique</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># compute the mean intensities of all regions</span>
    <span class="c1"># Note: Bug in mean implementation: means over labels is only computed if the indexes are also supplied</span>
    <span class="n">means</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">original_image</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">label_image</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels_unique</span><span class="p">)</span>
    
    <span class="c1"># compute the maximum possible intensity difference</span>
    <span class="n">max_difference</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">means</span><span class="p">)))</span>

    <span class="c1"># create a lookup table that relates region ids to their respective intensity values</span>
    <span class="n">means</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels_unique</span><span class="p">,</span> <span class="n">means</span><span class="p">)))</span>

    <span class="c1"># get the adjuncancy of the labels</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">__compute_edges</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># compute the difference of means for each adjunct region and add it as a tuple to the dictionary</span>
    <span class="k">if</span> <span class="mf">0.</span> <span class="o">==</span> <span class="n">max_difference</span><span class="p">:</span> <span class="c1"># special case when the divider is zero and therefore all values can be assured to equal zero</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="c1"># compute the difference of means for each adjunct region and add it as a tuple to the dictionary</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">means</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">means</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">max_difference</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="boundary_stawiaski"><a class="viewcode-back" href="../../../generated/medpy.graphcut.energy_label.boundary_stawiaski.html#medpy.graphcut.energy_label.boundary_stawiaski">[docs]</a><span class="k">def</span> <span class="nf">boundary_stawiaski</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">gradient_image</span><span class="p">):</span> <span class="c1"># label image is not required to hold continuous ids or to start from 1</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boundary term based on the sum of border voxel pairs differences.</span>
<span class="sd">     </span>
<span class="sd">    An implementation of the boundary term in [1]_, suitable to be used with the `~medpy.graphcut.generate.graph_from_labels` function.</span>
<span class="sd">    </span>
<span class="sd">    Determines for each two supplied regions the voxels forming their border assuming</span>
<span class="sd">    :math:`ndim*2`-connectedness (e.g. :math:`3*2=6` for 3D). From the gradient magnitude values of each</span>
<span class="sd">    end-point voxel the border-voxel pairs, the highest one is selected and passed to a</span>
<span class="sd">    strictly positive and decreasing function :math:`g(x)`, which is defined as:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        g(x) = \left(\frac{1}{1+|x|}\right)^k</span>
<span class="sd">    </span>
<span class="sd">    ,where :math:`k=2`. The final weight :math:`w_{i,j}` between two regions :math:`r_i` and</span>
<span class="sd">    :math:`r_j` is then determined by the sum of all these neighbour values:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        w_{i,j} = \sum_{e_{m,n}\in F_{(r_i,r_j)}}g(\max(|I(m)|,|I(n)|))</span>
<span class="sd">    </span>
<span class="sd">    , where :math:`F_{(r_i,r_j)}` is the set of border voxel-pairs :math:`e_{m,n}` between</span>
<span class="sd">    the regions :math:`r_i` and :math:`r_j` and :math:`|I(p)|` the absolute of the gradient</span>
<span class="sd">    magnitude at the voxel :math:`p`</span>
<span class="sd">    </span>
<span class="sd">    This boundary_function works as an edge indicator in the original image. In simpler</span>
<span class="sd">    words the weight (and therefore the energy) is obtained by summing the local contrast</span>
<span class="sd">    along the boundaries between two regions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : GCGraph</span>
<span class="sd">        The graph to add the weights to.</span>
<span class="sd">    label_image : ndarray</span>
<span class="sd">        The label image. Must contain consecutively labelled regions starting from index 1.</span>
<span class="sd">    gradient_image : ndarray</span>
<span class="sd">        The gradient image.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function requires the gradient magnitude image of the original image to be passed</span>
<span class="sd">    along. That means that `~medpy.graphcut.generate.graph_from_labels` has to be called</span>
<span class="sd">    with ``boundary_term_args`` set to the gradient image. This can be obtained e.g. with</span>
<span class="sd">    `generic_gradient_magnitude` and `prewitt` from `scipy.ndimage`.</span>
<span class="sd">    </span>
<span class="sd">    This function is tested on 2D and 3D images and theoretically works for all dimensionalities. </span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Stawiaski J., Decenciere E., Bidlaut F. &quot;Interactive Liver Tumor Segmentation</span>
<span class="sd">           Using Graph-cuts and watershed&quot; MICCAI 2008 participation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to arrays if necessary</span>
    <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">gradient_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gradient_image</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">label_image</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]:</span> <span class="c1"># strangely, this one is required to be ctype ordering</span>
        <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
        
    <span class="n">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="c1"># prepare slicer for all minus last and all minus first &quot;row&quot;</span>
        <span class="n">slicer_from</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slicer_to</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slicer_from</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slicer_to</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># slice views of keys</span>
        <span class="n">keys_from</span> <span class="o">=</span> <span class="n">label_image</span><span class="p">[</span><span class="n">slicer_from</span><span class="p">]</span>
        <span class="n">keys_to</span> <span class="o">=</span> <span class="n">label_image</span><span class="p">[</span><span class="n">slicer_to</span><span class="p">]</span>
        <span class="c1"># determine not equal keys</span>
        <span class="n">valid_edges</span> <span class="o">=</span> <span class="n">keys_from</span> <span class="o">!=</span> <span class="n">keys_to</span>
        <span class="c1"># determine largest gradient</span>
        <span class="n">gradient_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient_image</span><span class="p">[</span><span class="n">slicer_from</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient_image</span><span class="p">[</span><span class="n">slicer_to</span><span class="p">]))[</span><span class="n">valid_edges</span><span class="p">]</span>
        <span class="c1"># determine key order</span>
        <span class="n">keys_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">keys_from</span><span class="p">,</span> <span class="n">keys_to</span><span class="p">)[</span><span class="n">valid_edges</span><span class="p">]</span>
        <span class="n">keys_min</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">keys_from</span><span class="p">,</span> <span class="n">keys_to</span><span class="p">)[</span><span class="n">valid_edges</span><span class="p">]</span>
        <span class="c1"># set edges / nweights</span>
        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys_min</span><span class="p">,</span> <span class="n">keys_max</span><span class="p">,</span> <span class="n">gradient_max</span><span class="p">):</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">val</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># weight contribution of a single pixel</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">k2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="boundary_stawiaski_directed"><a class="viewcode-back" href="../../../generated/medpy.graphcut.energy_label.boundary_stawiaski_directed.html#medpy.graphcut.energy_label.boundary_stawiaski_directed">[docs]</a><span class="k">def</span> <span class="nf">boundary_stawiaski_directed</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">xxx_todo_changeme</span><span class="p">):</span> <span class="c1"># label image is not required to hold continuous ids or to start from 1</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Boundary term based on the sum of border voxel pairs differences, directed version.</span>
<span class="sd">    </span>
<span class="sd">    An implementation of the boundary term in [1]_, suitable to be used with the</span>
<span class="sd">    `~medpy.graphcut.generate.graph_from_labels` function.</span>
<span class="sd">    </span>
<span class="sd">    The basic definition of this term is the same as for `boundary_stawiaski`, but the</span>
<span class="sd">    edges of the created graph will be directed.</span>
<span class="sd">    </span>
<span class="sd">    This boundary_function works as an edge indicator in the original image. In simpler</span>
<span class="sd">    words the weight (and therefore the energy) is obtained by summing the local contrast</span>
<span class="sd">    along the boundaries between two regions.</span>
<span class="sd">    </span>
<span class="sd">    When the ``directedness`` parameter is set to zero, the resulting graph will be undirected</span>
<span class="sd">    and the behaviour equals `boundary_stawiaski`.</span>
<span class="sd">    When it is set to a positive value, light-to-dark transitions are favored i.e. voxels</span>
<span class="sd">    with a lower intensity (darker) than the objects tend to be assigned to the object.</span>
<span class="sd">    The boundary term is thus changed to:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">          g_{ltd}(x) = \left\{</span>
<span class="sd">              \begin{array}{l l}</span>
<span class="sd">                g(x) + \beta &amp; \quad \textrm{if $I_i &gt; I_j$}\\</span>
<span class="sd">                g(x) &amp; \quad \textrm{if $I_i \leq I_j$}\\</span>
<span class="sd">              \end{array} \right.</span>

<span class="sd">    With a negative value for ``directedness``, the opposite effect can be achieved i.e.</span>
<span class="sd">    voxels with a higher intensity (lighter) than the objects tend to be assigned to the</span>
<span class="sd">    object. The boundary term is thus changed to</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">      g_{dtl} = \left\{</span>
<span class="sd">          \begin{array}{l l}</span>
<span class="sd">            g(x) &amp; \quad \textrm{if $I_i &gt; I_j$}\\</span>
<span class="sd">            g(x) + \beta &amp; \quad \textrm{if $I_i \leq I_j$}\\</span>
<span class="sd">          \end{array} \right.</span>

<span class="sd">    Subsequently the :math:`g(x)` in the computation of :math:`w_{i,j}` is substituted by</span>
<span class="sd">    :math:`g_{ltd}` resp. :math:`g_{dtl}`. The value :math:`\beta` determines the power of the</span>
<span class="sd">    directedness and corresponds to the absolute value of the supplied ``directedness``</span>
<span class="sd">    parameter. Experiments showed values between 0.0001 and 0.0003 to be good candidates.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : GCGraph</span>
<span class="sd">        The graph to add the weights to.</span>
<span class="sd">    label_image : ndarray</span>
<span class="sd">        The label image.  Must contain consecutively labelled regions starting from index 1.</span>
<span class="sd">    gradient_image : ndarray</span>
<span class="sd">        The gradient image.</span>
<span class="sd">    directedness : integer</span>
<span class="sd">        The weight of the directedness, a positive number to favour</span>
<span class="sd">        light-to-dark and a negative to dark-to-light transitions. See function</span>
<span class="sd">        description for more details.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function requires the gradient magnitude image of the original image to be passed</span>
<span class="sd">    along. That means that `~medpy.graphcut.generate.graph_from_labels` has to be called</span>
<span class="sd">    with ``boundary_term_args`` set to the gradient image. This can be obtained e.g. with</span>
<span class="sd">    `generic_gradient_magnitude` and `prewitt` from `scipy.ndimage`.</span>
<span class="sd">    </span>
<span class="sd">    This function is tested on 2D and 3D images and theoretically works for all dimensionalities.</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Stawiaski J., Decenciere E., Bidlaut F. &quot;Interactive Liver Tumor Segmentation</span>
<span class="sd">           Using Graph-cuts and watershed&quot; MICCAI 2008 participation    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">gradient_image</span><span class="p">,</span> <span class="n">directedness</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme</span>
    <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">gradient_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gradient_image</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">label_image</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">]:</span> <span class="c1"># strangely one this one is required to be ctype ordering</span>
        <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
        
    <span class="n">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
        
    <span class="n">beta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">directedness</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">addition_directed_ltd</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">dic</span><span class="p">):</span> <span class="c1"># for light-to-dark # tested</span>
        <span class="s2">&quot;Takes a key defined by two uints, two voxel intensities and a dict to which it adds g(v1, v2).&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key1</span> <span class="o">==</span> <span class="n">key2</span><span class="p">:</span> <span class="c1"># do not process voxel pairs which belong to the same region</span>
            <span class="c1"># The function used to compute the weight contribution of each voxel pair</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v2</span><span class="p">))),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># ensure that no value is zero; this can occur due to rounding errors</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="c1"># add weighted values to already existing edge</span>
            <span class="k">if</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">key1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">beta</span><span class="p">),</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">key1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))</span>
            
    <span class="k">def</span> <span class="nf">addition_directed_dtl</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span> <span class="c1"># for dark-to-light # tested</span>
        <span class="s2">&quot;Takes a key defined by two uints, two voxel intensities and a dict to which it adds g(v1, v2).&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key1</span> <span class="o">==</span> <span class="n">key2</span><span class="p">:</span> <span class="c1"># do not process voxel pairs which belong to the same region</span>
            <span class="c1"># The function used to compute the weight contribution of each voxel pair</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v2</span><span class="p">))),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># ensure that no value is zero; this can occur due to rounding errors</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="c1"># add weighted values to already existing edge</span>
            <span class="k">if</span> <span class="n">v1</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">key1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">graph</span><span class="o">.</span><span class="n">set_nweight</span><span class="p">(</span><span class="n">key1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span> <span class="o">+</span> <span class="n">beta</span><span class="p">),</span> <span class="n">weight</span><span class="p">)</span>
                                                  
    <span class="c1"># pick and vectorize the function to achieve a speedup</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">directedness</span><span class="p">:</span>
        <span class="n">vaddition</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">addition_directed_dtl</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vaddition</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">addition_directed_ltd</span><span class="p">)</span>
    
    <span class="c1"># iterate over each dimension</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">slices_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">slices_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">di</span> <span class="o">==</span> <span class="n">dim</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">slices_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">di</span> <span class="o">==</span> <span class="n">dim</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">vaddition</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">slices_x</span><span class="p">],</span>
                  <span class="n">label_image</span><span class="p">[</span><span class="n">slices_y</span><span class="p">],</span>
                  <span class="n">gradient_image</span><span class="p">[</span><span class="n">slices_x</span><span class="p">],</span>
                  <span class="n">gradient_image</span><span class="p">[</span><span class="n">slices_y</span><span class="p">])</span></div>

<div class="viewcode-block" id="regional_atlas"><a class="viewcode-back" href="../../../generated/medpy.graphcut.energy_label.regional_atlas.html#medpy.graphcut.energy_label.regional_atlas">[docs]</a><span class="k">def</span> <span class="nf">regional_atlas</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">xxx_todo_changeme1</span><span class="p">):</span> <span class="c1"># label image is required to hold continuous ids starting from 1</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regional term based on a probability atlas.</span>
<span class="sd">    </span>
<span class="sd">    An implementation of a regional term, suitable to be used with the</span>
<span class="sd">    `~medpy.graphcut.generate.graph_from_labels` function.</span>
<span class="sd">    </span>
<span class="sd">    This regional term introduces statistical probability of a voxel to belong to the</span>
<span class="sd">    object to segment. It computes the sum of all statistical atlas voxels under each</span>
<span class="sd">    region and uses this value as terminal node weight for the graph cut.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    graph : GCGraph</span>
<span class="sd">        The graph to add the weights to.</span>
<span class="sd">    label_image : ndarray</span>
<span class="sd">        The label image.</span>
<span class="sd">    probability_map : ndarray</span>
<span class="sd">        The probability atlas image associated with the object to segment.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        The energy terms alpha value, balancing between boundary and regional term. </span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function requires a probability atlas image of the same shape as the original image</span>
<span class="sd">    to be passed along. That means that `~medpy.graphcut.generate.graph_from_labels` has to</span>
<span class="sd">    be called with ``regional_term_args`` set to the probability atlas image.</span>
<span class="sd">    </span>
<span class="sd">    This function is tested on 2D and 3D images and theoretically works for all dimensionalities.    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">probability_map</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme1</span>
    <span class="n">label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">probability_map</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">probability_map</span><span class="p">)</span>
    <span class="n">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># finding the objects in the label image (bounding boxes around regions)</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
    <span class="c1"># iterate over regions and compute the respective sums of atlas values</span>
    <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probability_map</span><span class="p">[</span><span class="n">objects</span><span class="p">[</span><span class="n">rid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">label_image</span><span class="p">[</span><span class="n">objects</span><span class="p">[</span><span class="n">rid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">rid</span><span class="p">])</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_tweight</span><span class="p">(</span><span class="n">rid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">weight</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span> <span class="c1"># !TODO: rid&#39;s inside the graph start from 0 or 1? =&gt; seems to start from 0</span></div>
        <span class="c1"># !TODO: I can exclude source and sink nodes from this!</span>
        <span class="c1"># !TODO: I only have to do this in the range of the atlas objects!</span>


<span class="k">def</span> <span class="nf">__compute_edges</span><span class="p">(</span><span class="n">label_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the region neighbourhood defined by a star shaped n-dimensional structuring</span>
<span class="sd">    element (as returned by scipy.ndimage.generate_binary_structure(ndim, 1)) for the</span>
<span class="sd">    supplied region/label image.</span>
<span class="sd">    Note The returned set contains neither duplicates, nor self-references</span>
<span class="sd">    (i.e. (id_1, id_1)), nor reversed references (e.g. (id_1, id_2) and (id_2, id_1).</span>
<span class="sd">    </span>
<span class="sd">    @param label_image An image with labeled regions (nD).</span>
<span class="sd">    @param return A set with tuples denoting the edge neighbourhood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">__compute_edges_nd</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">__compute_edges_nd</span><span class="p">(</span><span class="n">label_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the region neighbourhood defined by a star shaped n-dimensional structuring</span>
<span class="sd">    element (as returned by scipy.ndimage.generate_binary_structure(ndim, 1)) for the</span>
<span class="sd">    supplied region/label image.</span>
<span class="sd">    Note The returned set contains neither duplicates, nor self-references</span>
<span class="sd">    (i.e. (id_1, id_1)), nor reversed references (e.g. (id_1, id_2) and (id_2, id_1).</span>
<span class="sd">    </span>
<span class="sd">    @param label_image An image with labeled regions (nD).</span>
<span class="sd">    @param return A set with tuples denoting the edge neighbourhood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Er</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
   
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">:</span>
            <span class="n">Er</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="nb">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))])</span>
        
    <span class="n">vappend</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>
   
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">slices_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">slices_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">di</span> <span class="o">==</span> <span class="n">dim</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">slices_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">di</span> <span class="o">==</span> <span class="n">dim</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">vappend</span><span class="p">(</span><span class="n">label_image</span><span class="p">[</span><span class="n">slices_x</span><span class="p">],</span> <span class="n">label_image</span><span class="p">[</span><span class="n">slices_y</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">Er</span>

<span class="k">def</span> <span class="nf">__check_label_image</span><span class="p">(</span><span class="n">label_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the label image for consistent labelling starting from 1.&quot;&quot;&quot;</span>
    <span class="n">encountered_indices</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
    <span class="n">expected_indices</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">encountered_indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">expected_indices</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> \
       <span class="ow">not</span> <span class="p">(</span><span class="n">encountered_indices</span> <span class="o">==</span> <span class="n">expected_indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;The supplied label image does either not contain any regions or they are not labeled consecutively starting from 1.&#39;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018, Oskar Maier.
      </li>
      <li>
      Last updated on Nov 23, 2018.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.7.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>
